---
title: Формирование вызовов с помощью GraphQL
intro: 'Узнайте, как выполнить проверку подлинности в API GraphQL, а затем узнайте, как создавать и выполнять запросы и изменения.'
redirect_from:
  - /v4/guides/forming-calls
  - /graphql/guides/forming-calls
versions:
  fpt: '*'
  ghec: '*'
  ghes: '*'
  ghae: '*'
topics:
  - API
shortTitle: Form calls with GraphQL
ms.openlocfilehash: 2b3a54415b563a8b07eecd21638b5f9c662a3d7c
ms.sourcegitcommit: d697e0ea10dc076fd62ce73c28a2b59771174ce8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/20/2022
ms.locfileid: '148094164'
---
## Проверка подлинности с помощью GraphQL

{% данных reusables.user-settings.graphql-classic-pat-only %}

Для взаимодействия с сервером GraphQL вам потребуется {% данных variables.product.pat_generic %} с нужными областями.

Выполните действия, описанные в разделе "[Создание {% данных variables.product.pat_generic %}](/github/authenticating-to-github/creating-a-personal-access-token)", чтобы создать маркер. Требуемые области зависят от запрашиваемого типа данных. Например, чтобы запросить данные пользователя, выберите области **пользователя**. Если нужен доступ к сведениям о репозитории, выберите соответствующие области **репозитория**.

{% ifversion fpt or ghec %}

Чтобы получить те же возможности, которые предоставляет [GraphQL Explorer](/graphql/guides/using-the-explorer), запросите следующие области:

{% else %}

Рекомендуются следующие области:

{% endif %}


```
repo
read:packages
read:org
read:public_key
read:repo_hook
user
read:discussion
read:enterprise
read:gpg_key
```

Если ресурсу требуется определенная область, интерфейс API уведомит вас об этом.

## Конечная точка GraphQL

REST API имеет множество конечных точек; API GraphQL — только одну:

<pre>{% data variables.product.graphql_url_pre %}</pre>

Конечная точка остается неизменной независимо от выполняемой операции.

## Взаимодействие с GraphQL

Так как операции GraphQL состоят из нескольких строк кода JSON, GitHub рекомендует использовать [Explorer](/graphql/guides/using-the-explorer) для выполнения вызовов GraphQL. Вы также можете использовать cURL или любую другую библиотеку, поддерживающую HTTP.

В REST [HTTP-команды](/rest#http-verbs) определяют выполняемую операцию. В GraphQL вы предоставите текст в кодировке JSON независимо от того, выполняете ли вы запрос или изменение, поэтому HTTP-команда — `POST`. Исключением является [запрос интроспекции](/graphql/guides/introduction-to-graphql#discovering-the-graphql-api), который представляет собой простой запрос `GET` к конечной точке. Дополнительные сведения о различиях между GraphQL и REST см. в разделе [Переход с REST на GraphQL](/graphql/guides/migrating-from-rest-to-graphql).

Чтобы выполнить запрос GraphQL с помощью cURL, выполните запрос `POST` с полезными данными JSON. Полезные данные должны содержать строку `query`:

```shell
curl -H "Authorization: bearer TOKEN" -X POST -d " \
 { \
   \"query\": \"query { viewer { login }}\" \
 } \
" {% data variables.product.graphql_url_code %}
```

{% tip %}

**Примечание**. В строковом значении `"query"` символы новой строки должны экранироваться, иначе оно будет неправильно проанализировано схемой. Для текста запроса `POST` используйте внешние двойные кавычки и экранированные внутренние двойные кавычки.

{% endtip %}

### Операции запроса и изменения

В API GraphQL на GitHub разрешены два типа операций: _запросы_ и _изменения_. Если сравнивать GraphQL с REST, запросы работают как запросы `GET`, а изменения — как `POST`/`PATCH`/`DELETE`. [Имя изменения](/graphql/reference/mutations) определяет производимую модификацию.

Сведения об ограничении скорости см. в разделе [Ограничения ресурсов GraphQL](/graphql/overview/resource-limitations).

Запросы и изменения похожи по форме за несколькими важными различиями.

### Сведения о запросах

Запросы GraphQL возвращают только указанные данные. Для формирования запроса необходимо указать [поля внутри полей](/graphql/guides/introduction-to-graphql#field) (также известные как _вложенные подполя_), пока не будут возвращены только [скалярные значения](/graphql/reference/scalars).

Запросы имеют следующую структуру:

<pre>query {
  JSON-OBJECT-TO-RETURN
}</pre>

Реальный пример см. в разделе [Пример запроса](#example-query).

### Сведения об изменениях

Чтобы сформировать изменение, необходимо указать три элемента.

1. _Имя изменения_ — тип нужного изменения.
2. _Входной объект_ — данные, которые необходимо отправить на сервер; состоят из _полей входных данных_. Передайте его в качестве аргумента имени изменения.
3. _Объект полезных данных_ — данные, которые должны быть получены с сервера; состоят из _возвращаемых полей_. Передайте его в качестве тела имени мутации.

Изменения имеют следующую структуру:

<pre>mutation {
  MUTATION-NAME(input: {MUTATION-NAME-INPUT!}) {
    MUTATION-NAME-PAYLOAD
  }
}</pre>

Входной объект в этом примере — `MutationNameInput`, а объект полезных данных — `MutationNamePayload`.

В справочнике по [изменениям](/graphql/reference/mutations) перечислены _поля входных данных_, передаваемые в качестве входного объекта. Кроме того, перечислены _возвращаемые поля_, передаваемые в качестве объекта полезных данных.

Реальный пример см. в разделе [Пример изменения](#example-mutation).

## Работа с переменными

[Переменные](https://graphql.github.io/learn/queries/#variables) могут сделать запросы более динамичными и эффективными, снизив сложность при передаче входных объектов изменений.

{% note %}

**Примечание**. Если вы используете Explorer, вводите переменные в отдельной [области "Переменные запроса"](/graphql/guides/using-the-explorer#using-the-variable-pane) и не добавляйте слово `variables` перед объектом JSON.

{% endnote %}

Ниже приведен пример запроса с одной переменной.

```graphql
query($number_of_repos:Int!) {
  viewer {
    name
     repositories(last: $number_of_repos) {
       nodes {
         name
       }
     }
   }
}
variables {
   "number_of_repos": 3
}
```

Переменные используются в три этапа.

1. Определите переменную вне операции в объекте `variables`:

  ```graphql
  variables {
     "number_of_repos": 3
  }
  ```

  Объект должен быть допустимым кодом JSON. В этом примере показана переменная простого типа `Int`, но можно определять переменные и более сложных типов, такие как входные объекты. Здесь также можно определить несколько переменных.

2. Передайте переменную в операцию в качестве аргумента:

  ```graphql
  query($number_of_repos:Int!){
  ```

  Аргумент представляет собой пару "ключ-значение", где ключ — это _имя_, начинающееся с `$` (например, `$number_of_repos`), а значение — это _тип_ (например, `Int`). Чтобы указать, что тип является обязательным, добавьте `!`. Если вы определили несколько переменных, включите их здесь как несколько аргументов.

3. Используйте переменную в операции:

  ```graphql
  repositories(last: $number_of_repos) {
  ```

  В этом примере переменная означает количество получаемых репозиториев. Тип указывается на шаге 2, так как в GraphQL действует строгая типизация.

Этот процесс делает аргумент запроса динамическим. Теперь мы можем просто изменить значение в объекте `variables`, оставив остальную часть запроса без изменений.

Использование переменных в качестве аргументов позволяет динамически обновлять значения в объекте `variables`, не меняя запрос.

## Пример запроса

Давайте рассмотрим более сложный запрос в контексте.

Следующий запрос обращается к репозиторию `octocat/Hello-World`, находит 20 последних закрытых проблем и возвращает заголовок, URL-адрес и первые пять меток каждой проблемы:

```graphql
query {
  repository(owner:"octocat", name:"Hello-World") {
    issues(last:20, states:CLOSED) {
      edges {
        node {
          title
          url
          labels(first:5) {
            edges {
              node {
                name
              }
            }
          }
        }
      }
    }
  }
}
```

Рассмотрим его структуру построчно.

* `query {`

  Так как мы хотим считать данные с сервера, а не изменить их, `query` является корневой операцией. (Если операция не указана, `query` также выполняется по умолчанию.)

* `repository(owner:"octocat", name:"Hello-World") {`

  Сначала нужно найти объект [`repository`](/graphql/reference/objects#repository). Проверка схемы показывает, что для этого объекта требуются аргументы `owner` и `name`.

* `issues(last:20, states:CLOSED) {`

  Чтобы получить сведения о всех проблемах в репозитории, мы вызываем объект `issues`. (Мы _могли бы_ запросить одну проблему `issue` из объекта `repository`, но для этого нужно знать количество возвращаемых проблем и предоставить его в качестве аргумента.)

  Некоторые сведения об объекте `issues`:

  - В [документации](/graphql/reference/objects#repository) говорится, что этот объект имеет тип `IssueConnection`.
  - Проверка схемы показывает, что в качестве аргумента для этого объекта требуется количество последних (`last`) или первых (`first`) результатов, поэтому мы указываем `20`.
  - В [документации](/graphql/reference/objects#repository) также говорится, что этот объект принимает аргумент `states`, который содержит одно из значений перечисления [`IssueState`](/graphql/reference/enums#issuestate): `OPEN` или `CLOSED`. Чтобы найти только закрытые проблемы, мы присваиваем ключу `states` значение `CLOSED`.

* `edges {`

  Мы знаем, что объект `issues` — это соединение, так как он имеет тип `IssueConnection`. Чтобы получить сведения об отдельных проблемах, необходимо получить доступ к узлу через `edges`.

* `node {`

  В данном случае мы получаем узлы в конце ребра. В [документации по `IssueConnection`](/graphql/reference/objects#issueconnection) указано, что узел в конце типа `IssueConnection` является объектом `Issue`.

* Теперь, когда мы знаем, что извлекаем объект `Issue`, мы можем обратиться к [документации](/graphql/reference/objects#issue) и указать поля, которые нужно вернуть:

  ```graphql
  title
  url
  labels(first:5) {
    edges {
      node {
        name
      }
    }
  }
  ```

  В данном случае мы указываем поля `title`, `url` и `labels` объекта `Issue`.

  Тип поля `labels` — [`LabelConnection`](/graphql/reference/objects#labelconnection). Как и в случае с объектом `issues`, так как `labels` — это соединение, необходимо пройти по его ребрам к подключенному узлу: объекту `label`. В этом узле можно указать поля объекта `label`, которые нужно вернуть, в данном случае `name`.

Вы можете заметить, что при выполнении этого запроса в {% ifversion not ghae %}общедоступном{% endif %} репозитории Octocat `Hello-World` возвращается небольшое количество меток. Попробуйте выполнить его в одном из собственных репозиториев, использующих метки, и вы, скорее всего, заметите разницу.

## Пример изменения

Для изменений часто требуются сведения, которые можно узнать только путем предварительного выполнения запроса. В этом примере показаны две операции:

1. запрос для получения идентификатора проблемы;
2. изменение для добавления реакции эмодзи на проблему.

```graphql
query FindIssueID {
  repository(owner:"octocat", name:"Hello-World") {
    issue(number:349) {
      id
    }
  }
}

mutation AddReactionToIssue {
  addReaction(input:{subjectId:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {
    reaction {
      content
    }
    subject {
      id
    }
  }
}
```

{% tip %}

Хотя запрос и изменение можно добавить в одном окне Explorer, если присвоить им имена (в данном примере `FindIssueID` и `AddReactionToIssue`), операции будут выполняться как отдельные вызовы конечной точки GraphQL. Запрос невозможно выполнить одновременно с изменением, и наоборот.

{% endtip %}

Разберем этот пример. Задача звучит просто: добавить реакцию эмодзи на проблему.

С какого же запроса нам начать? Пока мы не знаем.

Так как мы хотим изменить данные на сервере (добавить эмодзи к проблеме), мы начинаем с поиска подходящего изменения в схеме. В справочной документации есть изменение [`addReaction`](/graphql/reference/mutations#addreaction) с таким описанием: `Adds a reaction to a subject.` Отлично!

В документации по изменению перечислены три поля входных данных:

* `clientMutationId` (`String`)
* `subjectId` (`ID!`)
* `content` (`ReactionContent!`)

Символы `!` указывают, что `subjectId` и `content` являются обязательными полями. То, что поле `content` обязательное, разумно: мы хотим добавить реакцию, поэтому нам нужно указать, какой эмодзи следует использовать.

Но почему обязательным является поле `subjectId`? Это связано с тем, что `subjectId` — это единственный способ указать, на _какую_ проблему в _каком_ репозитории следует отреагировать.

Вот почему мы начинаем этот пример с запроса: чтобы получить `ID`.

Давайте разберем запрос построчно.

* `query FindIssueID {`

  Здесь мы выполняем запрос и называем его `FindIssueID`. Обратите внимание, что именование запроса является необязательным. В данном случае мы присваиваем ему имя, чтобы можно было включить его в то же окно Explorer, что и изменение.

* `repository(owner:"octocat", name:"Hello-World") {`

  Мы указываем репозиторий, запрашивая объект `repository` и передавая аргументы `owner` и `name`.

* `issue(number:349) {`

  Мы указываем проблему, на которую нужно отреагировать, запрашивая объект `issue` и передавая аргумент `number`.

* `id`

  Здесь мы получаем `id` `https://github.com/octocat/Hello-World/issues/349` для передачи в `subjectId`.

При выполнении запроса мы получаем `id` `MDU6SXNzdWUyMzEzOTE1NTE=`.

{% tip %}

**Примечание**. Возвращаемое в запросе значение `id` — это значение, которое мы передадим как `subjectID` в изменении. Ни в документации, ни в схеме эта связь не определена. Необходимо просто понимать, как работают имена.

{% endtip %}

Зная идентификатор, мы можем перейти к изменению:

* `mutation AddReactionToIssue {`

  Здесь мы выполняем изменение и называем его `AddReactionToIssue`. Как и в случае с запросами, именование изменения является необязательным. В данном случае мы присваиваем ему имя, чтобы можно было включить его в то же окно Explorer, что и запрос.

* `addReaction(input:{subjectId:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {`

  Разберем эту строку:

  - `addReaction` — это имя изменения.
  - `input` — это обязательный ключ аргумента. Для изменения это всегда `input`.
  - `{subjectId:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}` — это обязательное значение аргумента. Для изменения это всегда будет [входной объект](/graphql/reference/input-objects) (отсюда фигурные скобки), состоящий из полей входных данных (в данном случае `subjectId` и `content`).

  Как узнать, какое значение следует использовать для содержимого? В [документации по `addReaction`](/graphql/reference/mutations#addreaction) говорится, что поле `content` имеет тип [`ReactionContent`](/graphql/reference/enums#reactioncontent), который является [перечислением](/graphql/reference/enums), так как для проблем GitHub поддерживаются только некоторые реакции эмодзи. Ниже перечислены допустимые значения для реакций (обратите внимание, что некоторые значения отличаются от соответствующих имен эмодзи).

  {% data reusables.repositories.reaction_list %}

* Остальная часть вызова — это объект полезных данных. Здесь мы указываем данные, которые сервер должен вернуть после изменения. В [документации по `addReaction`](/graphql/reference/mutations#addreaction) определены три возможных возвращаемых поля:

    - `clientMutationId` (`String`)
    - `reaction` (`Reaction!`)
    - `subject` (`Reactable!`)

  В этом примере возвращаются два обязательных поля (`reaction` и `subject`); оба они имеют обязательные вложенные поля (`content` и `id` соответственно).

При выполнении изменения ответ будет следующим:

```json
{
  "data": {
    "addReaction": {
      "reaction": {
        "content": "HOORAY"
      },
      "subject": {
        "id": "MDU6SXNzdWUyMTc5NTQ0OTc="
      }
    }
  }
}
```

Вот и все! Проверьте [реакцию на проблему](https://github.com/octocat/Hello-World/issues/349), наведя указатель мыши на :tada: и посмотрев имя пользователя.

Последнее замечание: при передаче нескольких полей во входном объекте синтаксис может получиться громоздким. Помочь может помещение полей в [переменную](#working-with-variables). Вот как можно переписать исходное изменение с использованием переменной:

```graphql
mutation($myVar:AddReactionInput!) {
  addReaction(input:$myVar) {
    reaction {
      content
    }
    subject {
      id
    }
  }
}
variables {
  "myVar": {
    "subjectId":"MDU6SXNzdWUyMTc5NTQ0OTc=",
    "content":"HOORAY"
  }
}
```

{% note %}

Вы можете заметить, что в значении поля `content` в предыдущем примере (где оно используется в изменении напрямую) нет кавычек вокруг `HOORAY`, но при использовании в переменной кавычки есть. Этому есть причина:
* При использовании `content` в изменении напрямую схема предполагает, что значение имеет тип [`ReactionContent`](/graphql/reference/enums#reactioncontent), который является _перечислением_, а не строкой. Если добавить кавычки вокруг значения перечисления, при проверке схемы возникнет ошибка, так как кавычки зарезервированы для строк.
* При использовании `content` в переменной раздел переменных должен быть допустимым кодом JSON, поэтому кавычки требуются. Проверка схемы правильно интерпретирует тип `ReactionContent`, когда переменная передается в изменение во время выполнения.

Дополнительные сведения о различиях между перечислениями и строками см. в [официальной спецификации GraphQL](https://graphql.github.io/graphql-spec/June2018/#sec-Enums).

{% endnote %}

## Дополнительные материалы

При формировании вызовов GraphQL доступно _гораздо_ больше возможностей. Дополнительную информацию можно найти в следующих ресурсах:

* [Разбиение на страницы](https://graphql.org/learn/pagination/)
* [Фрагменты](https://graphql.org/learn/queries/#fragments)
* [Встроенные фрагменты](https://graphql.org/learn/queries/#inline-fragments)
* [Директивы](https://graphql.org/learn/queries/#directives)
