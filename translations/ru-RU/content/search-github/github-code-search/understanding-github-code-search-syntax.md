---
title: Основные сведения о синтаксисе поиска кода GitHub (бета-версия)
intro: 'Вы можете создавать поисковые запросы для нужных результатов с помощью специализированных квалификаторов кода, регулярных выражений и логических операций.'
allowTitleToDifferFromFilename: true
versions:
  feature: github-code-search
topics:
  - GitHub search
ms.openlocfilehash: 098da2b7fe8a8c5466805c583e6b029b5b9b58c1
ms.sourcegitcommit: e8c012864f13f9146e53fcb0699e2928c949ffa8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2022
ms.locfileid: '148160066'
---
{% note %}

**Примечание.** {% data reusables.search.code-search-code-view-beta-note %}

{% data reusables.search.code-search-link %} {% data reusables.search.code-view-link %}

{% endnote %}

## Сведения о новой структуре запросов поиска кода (бета-версия)

Синтаксис поиска в этой статье применяется только к коду с включенным новым поиском кода (бета-версия). {% data reusables.search.non-code-search-explanation %}

Поисковые запросы состоят из условий поиска, содержащих текст, который требуется найти, и квалификаторов, которые сужают область поиска. 

Пустой термин без квалификаторов будет соответствовать содержимому файла или пути к файлу. 

Например, следующий запрос:

```
http-push
```

Приведенный выше запрос будет соответствовать файлу `docs/http-push.txt`, даже если он не содержит термин `http-push`. Он также будет соответствовать файлу с именем `example.txt` , если он содержит термин `http-push`. 

Вы можете ввести несколько терминов, разделенных пробелами, чтобы найти документы, удовлетворяющие обоим условиям. 

Например, следующий запрос:

```
sparse index
```

Результаты поиска будут включать все документы, содержащие термины `sparse` и `index`, в любом порядке. В качестве примеров он будет соответствовать файлу с , файлу `SparseIndexVector`с фразой `index for sparse trees`и даже файлу с именем `index.txt` , который содержит термин `sparse`.  

Поиск нескольких терминов, разделенных пробелами, эквивалентен поиску `hello AND world`. Другие логические операции, такие как `hello OR world`, также поддерживаются в новом поиске кода (бета-версия). Дополнительные сведения о логических операциях см. в разделе [Использование логических операций](#using-boolean-operations).

Новый поиск кода (бета-версия) также поддерживает поиск точной строки, включая пробелы. Дополнительные сведения см. в разделе [Запрос точного соответствия](#query-for-an-exact-match).

Поиск кода можно сузить с помощью специализированных квалификаторов, таких как `repo:`, `language:` и `path:`. Дополнительные сведения о квалификаторах, которые можно использовать в новом поиске кода (бета-версия), см. в разделе [Использование квалификаторов](#using-qualifiers).

Вы также можете использовать регулярные выражения в поисках, окружив выражение в обратных косых чертах. Дополнительные сведения об использовании регулярных выражений см. в разделе [Использование регулярных выражений](#using-regular-expressions).

## Запрос точного соответствия

Чтобы найти точную строку, включая пробелы, можно заключить строку в кавычки. Например:

```
"sparse index"
```

Чтобы найти фразу, содержащую кавычки, можно экранировать кавычки с помощью обратной косой черты. Например, чтобы найти точную строку `name = "tensorflow"`, можно выполнить поиск:

```
"name = \"tensorflow\""
```

Строки в кавычках также можно использовать в квалификаторах, например:

```
path: git language: "protocol buffers"
```

## Использование логических операций

Новый поиск кода (бета-версия) поддерживает логические выражения. Операторы `AND`, `OR`и `NOT` можно использовать для объединения условий поиска.

По умолчанию смежные термины, разделенные пробелами, эквивалентны использованию `AND` оператора . Например, поисковый запрос `sparse index` совпадает `sparse AND index`с , а это означает, что результаты поиска будут включать все документы, содержащие как термины `sparse` , так и `index`, в любом порядке.

Для поиска документов, содержащих один или другой термин, можно использовать `OR` оператор . Например, следующий запрос будет соответствовать документам, содержащим или `sparse` `index`:

```
sparse OR index
```

Чтобы исключить файлы из результатов поиска, можно использовать `NOT` оператор . Например, чтобы исключить файл в каталоге `__testing__` , можно выполнить поиск:

```
"fatal error" NOT path:__testing__
```

Круглые скобки можно использовать для выражения более сложных логических выражений. Например:

```
(language:ruby OR language:python) AND NOT path:"/tests/"
```

## Использование квалификаторов

Для уточнения поиска можно использовать специализированные ключевые слова.
- [Квалификатор репозитория](#repository-qualifier)
- [Квалификаторы организации и пользователей](#organization-and-user-qualifiers)
- [Квалификатор языка](#language-qualifier)
- [Квалификатор пути](#path-qualifier)
- [Квалификатор символов](#symbol-qualifier)
- [Квалификатор содержимого](#content-qualifier)
- [Квалификатор is](#is-qualifier)

### Квалификатор репозитория

Для поиска в репозитории `repo:` используйте квалификатор. Необходимо указать полное имя репозитория, включая владельца. Например:

```
repo:github/linguist
```

Для поиска в наборе репозиториев можно объединить несколько `repo:` квалификаторов с логическим оператором `OR`. Пример:

```
repo:github/linguist OR repo:tree-sitter/tree-sitter
```

{% note %}

**Примечание:** Новая бета-версия поиска кода в настоящее время не поддерживает регулярные выражения или частичное сопоставление имен репозитория, поэтому для работы квалификатора необходимо ввести все имя репозитория (включая префикс `repo:` пользователя).

{% endnote %}

### Квалификаторы организации и пользователей

Для поиска файлов в организации используйте `org:` квалификатор. Например:

```
org:github
```

Для поиска файлов в личной учетной записи используйте `user:` квалификатор. Пример:

```
user:octocat
```

{% note %}

**Примечание:** Новая бета-версия поиска кода в настоящее время не поддерживает регулярные выражения или частичное сопоставление для имен организаций или пользователей, поэтому вам придется ввести всю организацию или имя пользователя, чтобы квалификатор работал.

{% endnote %}


### Квалификатор языка

Чтобы сузить область до определенных языков, используйте `language:` квалификатор. Например: 

```
language: ruby OR language:cpp OR language:csharp
```

Полный список поддерживаемых имен языков см. в разделе [languages.yaml](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml) в [github/linguist](https://github.com/github/linguist). Если предпочитаемый язык отсутствует в списке, можно открыть запрос на вытягивание, чтобы добавить его.

### Квалификатор пути

Для поиска в путях к файлам `path:` используйте квалификатор. Это будет соответствовать файлам, содержащим термин в любом месте пути к файлу. Например, чтобы найти файлы, содержащие термин `unit_tests` в пути, используйте:

```
path:unit_tests
```
 Приведенный выше запрос будет соответствовать обоим `src/unit_tests/my_test.py` и `src/docs/unit_tests.md` , так как оба они содержат `unit_test` где-то в своем пути. 

 Чтобы сопоставить только определенное имя файла (а не часть пути), можно использовать регулярное выражение:

 ```
 path:/(^|\/)README\.md$/
 ```
Обратите внимание, что `.` в имени файла экранируется, так как `.` имеет особое значение для регулярных выражений. Дополнительные сведения об использовании регулярных выражений см. в разделе [Использование регулярных выражений](#using-regular-expressions).

<br>

В квалификаторе также можно использовать некоторые ограниченные `path:` выражения glob.

Например, для поиска файлов с расширением `txt`можно использовать:

```
path:*.txt
```
<br>
Для поиска файлов JavaScript в каталоге `src` можно использовать:

```
path:src/*.js
```

- По умолчанию выражения glob не привязаны к началу пути, поэтому приведенное выше выражение по-прежнему будет соответствовать пути, например `app/src/main.js`. Но если префикс выражения с `/`помощью , оно будет привязано к началу. Например:

    ```
    path:/src/*.js
    ```
- Обратите внимание, что `*` не соответствует символу `/` , поэтому в приведенном выше примере все результаты будут прямыми `src` потомками каталога. Для сопоставления в подкаталогах, чтобы результаты включали глубоко вложенные файлы, такие как `/src/app/testing/utils/example.js`, можно использовать .`**` Например:

    ```
    path:/src/**/*.js
    ```
<br>

Можно также использовать глобальный `?` символ. Например, чтобы сопоставить путь `file.aac` или `file.abc`, можно использовать:

```
path:*.a?c
```
<br>
Чтобы найти имя файла, содержащее специальный символ, например `*` или `?`, просто используйте строку в кавычках:

```
path:"file?"
```

Так как выражения glob отключены для строк в кавычках, приведенный выше запрос будет соответствовать только путям, содержащим строку `file?`литерала . 

### Квалификатор символов

Вы можете искать определения символов в коде, например определения функций или классов, с помощью `symbol:` квалификатора. Поиск символов основан на анализе кода с помощью экосистемы средства синтаксического анализа открытый код [Tree-sitter](https://github.com/tree-sitter), поэтому дополнительная настройка или интеграция средств сборки не требуется.

Например, чтобы найти символ с именем `WithContext`:

```
language:go symbol:WithContext
```

В некоторых языках можно искать символы, используя префикс (например, префикс имени класса). Например, для метода `deleteRows` в структуре `Maint`можно выполнить поиск `symbol:Maint.deleteRows` , если вы используете Go или `symbol:Maint::deleteRows` в Rust.

Можно также использовать регулярные выражения с квалификатором символов. Например, следующий запрос найдет преобразования, которые люди реализовали в Rust для `String` типа :

```
language:rust symbol:/^String::to_.*/
```

Обратите внимание, что этот квалификатор ищет только определения, а не ссылки, и пока не все типы символов или языки полностью поддерживаются. Извлечение символов поддерживается для следующих языков. 

- C#
- Python
- Go
- Java
- JavaScript
- TypeScript
- PHP
- Protocol Buffers
- Ruby
- Rust

Мы работаем над добавлением поддержки дополнительных языков. Если вы хотите внести свой вклад в эту работу, вы можете добавить поддержку своего языка в экосистеме синтаксического [анализатора открытый код tree-sitter](https://github.com/tree-sitter), на которой основан поиск символов.

### Квалификатор содержимого

По умолчанию голые термины ищут как пути, так и содержимое файла. Чтобы ограничить поиск только содержимым файла, а не путями к файлу `content:` , используйте квалификатор. Например:

```
content:README.md
```

Этот запрос будет сопоставлять только файлы, содержащие термин `README.md`, а не соответствующие файлы с именем `README.md`. 

### Является квалификатором

Для фильтрации по свойствам `is:` документа можно использовать квалификатор. В настоящее время в этом квалификаторе поддерживается `archived`только значение , которое ограничивает поиск архивными репозиториями. Например:

```
path:/MIT.txt is:archived
```

Обратите внимание, что `is:` квалификатор можно инвертировать с помощью `NOT` оператора . Для поиска неархивированных репозиториев можно выполнить поиск:

```
log4j NOT is:archived
```

## Использование регулярных выражений

Новый поиск кода (бета-версия) поддерживает регулярные выражения для поиска шаблонов в коде. Регулярные выражения можно использовать в терминах поиска на пустом языке, а также во многих квалификаторов, окружив регулярное выражение в обратных косых чертах. 

Например, для поиска регулярного выражения `sparse.*index`следует использовать:

```
/sparse.*index/
```

Обратите внимание, что вам придется экранировать все косые черты в регулярном выражении. Например, для поиска файлов в каталоге `App/src` используется:

```
/^App\/src\//
```
