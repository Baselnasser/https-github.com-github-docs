---
title: Кэширование зависимостей для ускорения рабочих процессов
shortTitle: Cache dependencies
intro: 'Чтобы повысить скорость и эффективность рабочих процессов, можно создавать и использовать кэши для зависимостей и других часто используемых файлов.'
redirect_from:
  - /github/automating-your-workflow-with-github-actions/caching-dependencies-to-speed-up-workflows
  - /actions/automating-your-workflow-with-github-actions/caching-dependencies-to-speed-up-workflows
  - /actions/configuring-and-managing-workflows/caching-dependencies-to-speed-up-workflows
  - /actions/guides/caching-dependencies-to-speed-up-workflows
  - /actions/advanced-guides/caching-dependencies-to-speed-up-workflows
versions:
  feature: actions-caching
type: tutorial
topics:
  - Workflows
miniTocMaxHeadingLevel: 3
ms.openlocfilehash: 380fe568e950a4dc388e8f811ecebd12f242c5df
ms.sourcegitcommit: 34d500fe45b362043b4b4685d6705a7bfb484d11
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2022
ms.locfileid: '148164383'
---
## Сведения о кэшировании зависимостей рабочего процесса

Рабочий процесс часто повторно использует одни и те же выходные данные или скачанные зависимости из одного запуска в другом. Например, средства управления пакетами и зависимостями, такие как Maven, Gradle, npm и Yarn, хранят локальный кэш скачанных зависимостей.

{% ifversion fpt or ghec %} Задания в средствах выполнения тестов, размещенных в {% data variables.product.prodname_dotcom %}, запускаются в чистом образе средства выполнения тестов и каждый раз должны загружать зависимости, что приводит к увеличению использования сети, времени выполнения и затрат. {% endif %}Чтобы ускорить повторное создание этих файлов, как и зависимостей, {% data variables.product.prodname_dotcom %} может кэшировать файлы, которые часто используются в рабочих процессах.

Чтобы кэшировать зависимости для задания, необходимо выполнить [действие `cache`](https://github.com/actions/cache) в {% data variables.product.prodname_dotcom %}. Это действие создает и восстанавливает кэш, определенный уникальным ключом. Кроме того, при кэшировании диспетчеров пакетов, перечисленных ниже, использование соответствующих действий setup-* требует минимальной конфигурации; после его выполнения будут созданы и восстановлены кэши зависимостей.

| Диспетчеры пакетов | Действие setup-* для кэширования |
|---|---|
| npm, Yarn, pnpm | [setup-node](https://github.com/actions/setup-node#caching-global-packages-data) |
| pip, pipenv, Poetry | [setup-python](https://github.com/actions/setup-python#caching-packages-dependencies) |
| Gradle, Maven | [setup-java](https://github.com/actions/setup-java#caching-packages-dependencies) |
| RubyGems | [setup-ruby](https://github.com/ruby/setup-ruby#caching-bundle-install-automatically) |
| Go `go.sum` | [setup-go](https://github.com/actions/setup-go#caching-dependency-files-and-build-outputs) |

{% warning %}

**Предупреждение**. {% ifversion fpt or ghec %}При использовании кэширования с {% data variables.product.prodname_actions %} учитывайте следующее:

* {% endif %}В кэше не рекомендуется хранить конфиденциальную информацию. Например, конфиденциальная информация может включать маркеры доступа или учетные данные для входа, хранящиеся в файле в пути к кэшу. Кроме того, программы интерфейса командной строки (CLI), такие как `docker login`, могут сохранять учетные данные для доступа в файле конфигурации. Любой пользователь с доступом на чтение может создать в репозитории запрос на вытягивание и получить доступ к содержимому кэша. Вилки репозитория также могут создавать запросы на вытягивание в базовой ветви и получить доступ к кэшу в базовой ветви.
{%- ifversion fpt or ghec %}
* При использовании локальных средств выполнения тестов кэши из рабочих процессов хранятся в облачном хранилище, принадлежащем {% data variables.product.company_short %}. Решение для принадлежащего клиенту хранилища доступно только с {% data variables.product.prodname_ghe_server %}.
{%- endif %}

{% endwarning %}

{% data reusables.actions.comparing-artifacts-caching %}

Дополнительные сведения об артефактах выполнения рабочего процесса см. в статье [Сохранение данных рабочего процесса с помощью артефактов](/github/automating-your-workflow-with-github-actions/persisting-workflow-data-using-artifacts).

## Ограничения доступа к кэшу

Ограничения доступа обеспечивают изоляцию кэша и защиту путем создания логической границы между разными ветвями и тегами. Запуски рабочих процессов могут восстанавливать кэши, созданные либо в текущей ветви, либо в ветви по умолчанию (обычно `main`). Если выполнение рабочего процесса запускается для запроса на вытягивание, он также может восстановить кэши, созданные в базовой ветви, включая базовые ветви разветвленных репозиториев. Например, если ветвь `feature-b` имеется базовая ветвь `feature-a`, запуск рабочего процесса, активировавшийся в запросе на вытягивание, будет иметь доступ к кэшам, созданным в ветви по умолчанию `main` , в базовой `feature-a` и текущей `feature-b` ветви.

Запуски рабочих процессов не могут восстанавливать кэши, созданные для дочерних или одноуровневых ветвей. Например, кэш, созданный для дочерней `feature-b` ветви, не будет доступен для запуска рабочего процесса, активированного в родительской `main` ветви. Аналогичным образом кэш, созданный для ветви с базой `main` , не будет доступен для ее одноуровневой `feature-c` ветви с базовой `main`.`feature-a` Запуски рабочих процессов также не могут восстановить кэши, созданные для разных имен тегов. Например, кэш, созданный для тега `release-a` с базой `main` , не будет доступен для запуска рабочего процесса, активированного для тега `release-b` с базовым `main`значением .

При создании кэша с помощью запуска рабочего процесса, активированного в запросе на вытягивание, создается кэш для ссылки на слияние (`refs/pull/.../merge`). Из-за этого кэш будет иметь ограниченную область и может быть восстановлен только при повторном выполнении запроса на вытягивание. Она не может быть восстановлена базовой ветвью или другими запросами на вытягивание, предназначенными для этой базовой ветви.

Несколько запусков рабочих процессов в репозитории могут совместно использовать кэши. Кэш, созданный для ветви в выполнении рабочего процесса, можно получить и восстановить из другого запуска рабочего процесса для того же репозитория и ветви.

## Использование действия `cache`

[Действие `cache`](https://github.com/actions/cache) попытается восстановить кэш на основе предоставленного вами `key`. Когда действие находит _кэш, точно_ соответствующий ключу, действие восстанавливает кэшированные файлы в настроенный `path` .
При необходимости можно указать список для `restore-keys` использования в случае, если `key` не соответствует существующему кэшу. Список `restore-keys` полезен при восстановлении кэша из другой ветви, так как `restore-keys` может _частично_ соответствовать ключам кэша. Дополнительные сведения о сопоставлении `restore-keys` см. в разделе [Сопоставление ключа кэша](#matching-a-cache-key).

Если имеется точное соответствие указанному `key`объекту , это считается попаданием в кэш. Если ни одного кэша точно не соответствует указанному `key`, это считается промахом кэша. При промахе кэша действие автоматически создает новый кэш, если задание завершается успешно. В новом кэше будет использоваться предоставленный вами `key`, а также будут содержаться файлы, указанные в `path`. Дополнительные сведения о том, как это обрабатывается, см. в разделе [Кэш попаданий и промахов](#cache-hits-and-misses).

Невозможно изменить содержимое существующего кэша. Вместо этого можно создать новый кэш с новым ключом.


### Входные параметры для действия `cache`

- `key`. **Требуется** Ключ, созданный при сохранении кэша, и ключ, используемый для поиска кэша. Это может быть любое сочетание переменных, значений контекста, статических строк и функций. Ключи имеют максимальную длину в 512 символов, а использование ключей большей длины приведет к сбою действия.
- `path`. **Требуется (требуются)** Путь (пути) в средстве выполнения тестов для кэширования или восстановления.
  - Вы можете указать один путь или добавить несколько путей в отдельных строках. Пример:

    ```
    - name: Cache Gradle packages
      uses: {% data reusables.actions.action-cache %}
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
    ```
  - Вы можете указать либо каталоги, либо отдельные файлы. Также поддерживаются стандартные маски.
  - Можно указать абсолютные пути или пути относительно каталога рабочей области.
- `restore-keys`. **Необязательно** Строка, содержащая альтернативные ключи восстановления, где каждый ключ восстановления, находится в новой строке. Если для `key` не происходит попадание в кэше, эти ключи восстановления используются последовательно в указанном порядке для поиска и восстановления кэша. Пример.

  {% raw %}
  ```yaml
  restore-keys: |
    npm-feature-${{ hashFiles('package-lock.json') }}
    npm-feature-
    npm-
  ```
  {% endraw %}

### Входные параметры для действия `cache`

- `cache-hit`. Логическое значение, указывающее, что для ключа найдено точное совпадение.

### Попадания и промахи кэша
Если `key` точно соответствует существующему кэшу, это называется _попаданием в кэш_, и действие восстанавливает кэшированные файлы в `path` каталог.

При отсутствии соответствия `key` существующему кэшу происходит _промах кэша_, и если задание успешно завершено, автоматически создается новый кэш.

При промахе кэша действие также выполняет поиск указанных `restore-keys` для любых совпадений:

1. При указании `restore-keys` действие `cache` последовательно ищет все кэши, соответствующие списку `restore-keys`.
   - При точном совпадении действие восстанавливает файлы в кэше в каталог `path`.
   - Если точных совпадений нет, действие ищет частичные совпадения ключей восстановления. Когда действие находит частичное совпадение, в каталог `path` восстанавливается самый последний кэш.
1. Действие `cache` завершается, и выполняется следующий шаг задания.
1. Если задание завершено успешно, действие автоматически создает новый кэш с содержимым каталога `path`.

Более подробное описание процесса сопоставления кэша см. в статье [Сопоставление ключа кэша](#matching-a-cache-key).

### Пример использования действия `cache`

В этом примере создается новый кэш при изменении пакетов в файле `package-lock.json` или при изменении операционной системы средства выполнения тестов. Ключ кэша использует контексты и выражения для создания ключа, который включает операционную систему средства выполнения тестов и хэш SHA-256 файла `package-lock.json`.

```yaml{:copy}
name: Caching with npm
on: push
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: {% data reusables.actions.action-checkout %}

      - name: Cache node modules
        id: cache-npm
        uses: {% data reusables.actions.action-cache %}
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: {% raw %}${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}{% endraw %}
          restore-keys: |
            {% raw %}${{ runner.os }}-build-${{ env.cache-name }}-{% endraw %}
            {% raw %}${{ runner.os }}-build-{% endraw %}
            {% raw %}${{ runner.os }}-{% endraw %}

      - if: {% raw %}${{ steps.cache-npm.outputs.cache-hit != 'true' }}{% endraw %}
        name: List the state of node modules
        continue-on-error: true
        run: npm list

      - name: Install dependencies
        run: npm install

      - name: Build
        run: npm build

      - name: Test
        run: npm test
```

### Использование контекстов для создания ключей кэша

Ключ кэша может включать любой из контекстов, функций, литералов и операторов, поддерживаемых {% data variables.product.prodname_actions %}. Дополнительные сведения см. в разделах [Контексты](/actions/learn-github-actions/contexts) и [Выражения](/actions/learn-github-actions/expressions).

Использование выражений для создания `key` позволяет автоматически создавать новый кэш при изменении зависимостей.

Например, можно создать `key` с помощью выражения, которое вычисляет хэш файла npm `package-lock.json`. Таким образом, при изменении зависимостей, составляющих изменение файла `package-lock.json`, изменяется ключ кэша и автоматически создается новый кэш.

{% raw %}
```yaml
npm-${{ hashFiles('package-lock.json') }}
```
{% endraw %}

{% data variables.product.prodname_dotcom %} вычисляет выражение `hash "package-lock.json"` для получения окончательного `key`.

```yaml
npm-d5ea0750
```

### Использование выходных данных действия `cache`

Выходные данные действия `cache` можно использовать для выполнения действий в зависимости от того, произошло ли попадание в кэш или произошел промах. В случае нахождения точного совпадения для кэша для указанного `key` для выходных данных `cache-hit` задается значение `true`.

В приведенном выше примере рабочего процесса есть шаг, в котором перечисляется состояние модулей Node в случае сбоя кэша:

```yaml
- if: {% raw %}${{ steps.cache-npm.outputs.cache-hit != 'true' }}{% endraw %}
  name: List the state of node modules
  continue-on-error: true
  run: npm list
```

## Сопоставление ключа кэша

Действие `cache` сначала ищет попадания `key` в кэш и _версию_ кэша в ветви, содержащей выполнение рабочего процесса. Если нажатие отсутствует, выполняется поиск `restore-keys` и _версия_. Если в текущей ветви по-прежнему нет совпадений, `cache` действие повторяет те же действия, что и в ветви по умолчанию. Обратите внимание, что ограничения области применяются во время поиска. Дополнительные сведения см. в разделе [Ограничения доступа к кэшу](#restrictions-for-accessing-a-cache).

Версия кэша — это способ пометить кэш метаданными `path` и средством сжатия, используемым при создании кэша. Это гарантирует уникальное соответствие выполняемого рабочего процесса кэшу, который он может фактически распаковыть и использовать. Дополнительные сведения см. в разделе [Версия кэша](https://github.com/actions/cache#cache-version) в документации по кэшу действий.

`restore-keys` позволяет указать список альтернативных ключей восстановления, используемых в случае промаха кэша в `key`. Можно создать несколько ключей восстановления, упорядоченных от наиболее определенных до наименее определенных. Действие `cache` выполняет поиск `restore-keys` в последовательном порядке. Если ключ не совпадает напрямую, действие выполняет поиск ключей с префиксом ключа восстановления. При наличии нескольких частичных совпадений для ключа восстановления действие возвращает последний созданный кэш.

### Пример использования нескольких ключей восстановления

{% raw %}
```yaml
restore-keys: |
  npm-feature-${{ hashFiles('package-lock.json') }}
  npm-feature-
  npm-
```
{% endraw %}

Средство выполнения тестов вычисляет выражения, которые разрешаются в следующие `restore-keys`:

{% raw %}
```yaml
restore-keys: |
  npm-feature-d5ea0750
  npm-feature-
  npm-
```
{% endraw %}

Ключ восстановления `npm-feature-` соответствует любому ключу, который начинается со строки `npm-feature-`. Например, оба ключа `npm-feature-fd3052de` и `npm-feature-a9b253ff` совпадают с ключом восстановления. Будет использоваться кэш с последней датой создания. Ключи в этом примере выполняются в следующем порядке:

1. **`npm-feature-d5ea0750`** соответствует определенному хэшу.
1. **`npm-feature-`** соответствует ключам кэша с префиксом `npm-feature-`.
1. **`npm-`** соответствует любым ключам с префиксом `npm-`.

#### Пример приоритета поиска

```yaml
key:
  npm-feature-d5ea0750
restore-keys: |
  npm-feature-
  npm-
```

Например, если запрос на вытягивание содержит ветвь `feature` и нацелен на ветвь по умолчанию (`main`), действие выполняет поиск `key` и `restore-keys` в следующем порядке:

1. Ключ `npm-feature-d5ea0750` в ветви `feature`
1. Ключ `npm-feature-` в ветви `feature`
1. Ключ `npm-` в ветви `feature`
1. Ключ `npm-feature-d5ea0750` в ветви `main`
1. Ключ `npm-feature-` в ветви `main`
1. Ключ `npm-` в ветви `main`

## Ограничения использования и политика вытеснения

{% data variables.product.prodname_dotcom %} удалит все записи кэша, к которым не удалось получить доступ в течение 7 дней. Количество кэшей, которые можно хранить, не ограничено, но общий размер всех кэшей в репозитории ограничен{% ifversion actions-cache-policy-apis %}. По умолчанию ограничение составляет 10 ГБ на репозиторий, но оно может отличаться в зависимости от политик, заданных владельцами предприятия или администраторами репозитория.{% else %} до 10 ГБ.{% endif %} 

{% data reusables.actions.cache-eviction-process %} {% ifversion actions-cache-ui %} Процесс вытеснения кэша может привести к обмотке кэша, при котором кэши создаются и удаляются с высокой частотой. Чтобы уменьшить это, можно просмотреть кэши для репозитория и выполнить корректирующие действия, такие как удаление кэширования из определенных рабочих процессов. Дополнительные сведения см. в разделе [Управление кэшами](#managing-caches). {% endif %} {% ifversion actions-cache-admin-ui %} Вы также можете увеличить предельный размер кэша для репозитория. Дополнительные сведения см. в разделе [Управление параметрами {% data variables.product.prodname_actions %} для репозитория](/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-cache-storage-for-a-repository).

{% elsif actions-cache-policy-apis %}

Сведения об изменении политик для ограничения размера кэша репозитория см. в разделах [Применение политик для {% data variables.product.prodname_actions %} в организации](/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-cache-storage-in-your-enterprise) и [Управление параметрами {% data variables.product.prodname_actions %} для репозитория](/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-cache-storage-for-a-repository).

{% endif %}

{% ifversion actions-cache-management %}

## Управление кэшами

{% ifversion actions-cache-ui %}

Для управления кэшами, созданными на основе рабочих процессов, можно:

- Просмотр списка всех записей кэша для репозитория.
- Отфильтруйте и сортируйте список кэшей, используя определенные метаданные, такие как размер кэша, время создания или время последнего обращения.
- Удаление записей кэша из репозитория.
- Мониторинг совокупного использования кэша для репозиториев и организаций.

Существует несколько способов управления кэшами для репозиториев.

- Использование веб-интерфейса {% data variables.product.prodname_dotcom %}, как показано ниже.
- Использование REST API. Дополнительные сведения см. в документации по REST API [{% data variables.product.prodname_actions %}](/rest/actions/cache).
- Установка расширения {% data variables.product.prodname_cli %} для управления кэшами из командной строки. Дополнительные сведения см. в разделе расширение [gh-actions-cache](https://github.com/actions/gh-actions-cache) .

{% else %}

Для управления кэшами можно использовать REST API {% data variables.product.product_name %}. {% ifversion actions-cache-list-delete-apis %} API можно использовать для перечисления и удаления записей кэша, а также просмотра использования кэша. {% elsif actions-cache-management %}В настоящее время вы можете использовать API для просмотра использования кэша, в будущих обновлениях ожидаются дополнительные функциональные возможности. {% endif %} Дополнительные сведения см. в документации к REST API по [кэшу {% data variables.product.prodname_actions %}](/rest/actions/cache).

Также можно установить расширение {% data variables.product.prodname_cli %} для управления кэшем из командной строки. Дополнительные сведения о расширении см. в [документации по расширению](https://github.com/actions/gh-actions-cache#readme). Дополнительные сведения о расширениях {% data variables.product.prodname_cli %} см. в статье "[Использование расширений GitHub CLI](/github-cli/github-cli/using-github-cli-extensions)".

{% endif %}

{% ifversion actions-cache-ui %}

### Просмотр записей кэша

Веб-интерфейс можно использовать для просмотра списка записей кэша для репозитория. В списке кэша можно увидеть, сколько дискового пространства использует каждый кэш, когда кэш был создан и когда кэш использовался в последний раз.

{% data reusables.repositories.navigate-to-repo %} {% data reusables.repositories.actions-tab %} {% data reusables.repositories.actions-cache-list %}
1. Просмотрите список записей кэша для репозитория.

   * Чтобы найти записи кэша, используемые для определенной ветви, щелкните раскрывающееся меню **Ветвь** и выберите ветвь. В списке кэша будут отображаться все кэши, используемые для выбранной ветви.
   * Для поиска записей кэша с определенным ключом кэша используйте синтаксис `key: key-name` в поле **Фильтр кэшей** . В списке кэша будут отображаться кэши из всех ветвей, где использовался ключ.

   ![Снимок экрана: список записей кэша](/assets/images/help/repository/actions-cache-entry-list.png)

### Удаление записей кэша

Пользователи с `write` доступом к репозиторию могут использовать веб-интерфейс {% data variables.product.prodname_dotcom %} для удаления записей кэша.

{% data reusables.repositories.navigate-to-repo %} {% data reusables.repositories.actions-tab %} {% data reusables.repositories.actions-cache-list %}
1. Справа от записи кэша, которую вы хотите удалить, щелкните {% octicon "trash" aria-label="The trash icon" %}. 

   ![Снимок экрана: список записей кэша](/assets/images/help/repository/actions-cache-delete.png)

{% endif %}

{% endif %}
